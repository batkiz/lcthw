# 练习0：准备

## 系统的选择
c语言与\*unix平台配合较好，因此应尽量选择使用\*unix的系统。
此外，应尽量使用命令行。

~~所以说我还是用子系统吧23333~~

## 文本编辑器
**不要纠结于最完美的编辑器**

## 不要使用IDE
~~这不就是我在做的吗（~~

# 练习1：启用编译器

## 问题0
`int argc, char *argv[]`是什么鬼

# 练习2：用Make来代替Python

## make
使用GNU make而不是gcc

Q: 为什么不用输入文件扩展名？当路径下有不同扩展名的文件时其会如何工作？

## makefile
文件中应用`Tab`键，而不能使用空格

## 感想
这本书不太适合用git管理。。。

# 练习3：格式化输出

## 0
>在附加题一节我可能会让你自己查找一些资料，并且弄明白它们。这对于一个自我学习的程序员来说相当重要。如果你一直在自己尝试了解问题之前去问其它人，你永远都不会学到独立解决问题。这会让你永远都不会在自己的技能上建立信心，并且总是依赖别人去完成你的工作。

## Makefile
how to write a Makefile?

# 练习4：Valgrind介绍

## 安装
* 通过自行编译安装

## 膜
最后程序退出了，Valgrind显示出一份摘要，告诉你程序有多烂。

#练习5：一个C程序的结构

## printf函数
* 可变参数数量

# 练习6：变量类型


# 练习7：更多变量和一些算数

## 占位符
`%e`?

## 头文件
果然少了头文件。。。

# 练习8：大小和数组

## 位数
看的出来，这本书还是32位时代的产物（

# 练习9：数组和字符串



# 练习10：字符串数组和循环

## `for`循环的工作机制
```
for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
```
* `INITIALIZER`中是用来初始化循环的代码，这个例子中它是`i = 0`。
* 接下来会检查`TEST`布尔表达式，如果为`false(0)`则跳过`CODE`，不做任何事情。
* 执行`CODE`，做它要做的任何事情。
* 在`CODE`执行之后会执行`INCREMENTER`部分，通常情况会增加一些东西，比如这个例子是`i++`。
* 然后跳到第二步继续执行，直到`TEST`为`false(0)`为止。


# 练习11：while循环和布尔表达式

## `while`循环
```
while(TEST) {
    CODE;
}
```

# 练习12：If, Else If, Else

## `if`语句格式
```
if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
```