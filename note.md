# 练习0：准备

## 系统的选择
c语言与\*unix平台配合较好，因此应尽量选择使用\*unix的系统。
此外，应尽量使用命令行。

~~所以说我还是用子系统吧23333~~

## 文本编辑器
**不要纠结于最完美的编辑器**

## 不要使用IDE
~~这不就是我在做的吗（~~

# 练习1：启用编译器

## 问题0
`int argc, char *argv[]`是什么鬼

# 练习2：用Make来代替Python

## make
使用GNU make而不是gcc

Q: 为什么不用输入文件扩展名？当路径下有不同扩展名的文件时其会如何工作？

## makefile
文件中应用`Tab`键，而不能使用空格

## 感想
这本书不太适合用git管理。。。

# 练习3：格式化输出

## 0
>在附加题一节我可能会让你自己查找一些资料，并且弄明白它们。这对于一个自我学习的程序员来说相当重要。如果你一直在自己尝试了解问题之前去问其它人，你永远都不会学到独立解决问题。这会让你永远都不会在自己的技能上建立信心，并且总是依赖别人去完成你的工作。

## Makefile
how to write a Makefile?

# 练习4：Valgrind介绍

## 安装
* 通过自行编译安装

## 膜
最后程序退出了，Valgrind显示出一份摘要，告诉你程序有多烂。

#练习5：一个C程序的结构

## printf函数
* 可变参数数量

# 练习6：变量类型


# 练习7：更多变量和一些算数

## 占位符
`%e`?

## 头文件
果然少了头文件。。。

# 练习8：大小和数组

## 位数
看的出来，这本书还是32位时代的产物（

# 练习9：数组和字符串



# 练习10：字符串数组和循环

## `for`循环的工作机制
```
for(INITIALIZER; TEST; INCREMENTER) {
    CODE;
}
```
* `INITIALIZER`中是用来初始化循环的代码，这个例子中它是`i = 0`。
* 接下来会检查`TEST`布尔表达式，如果为`false(0)`则跳过`CODE`，不做任何事情。
* 执行`CODE`，做它要做的任何事情。
* 在`CODE`执行之后会执行`INCREMENTER`部分，通常情况会增加一些东西，比如这个例子是`i++`。
* 然后跳到第二步继续执行，直到`TEST`为`false(0)`为止。


# 练习11：while循环和布尔表达式

## `while`循环
```
while(TEST) {
    CODE;
}
```

# 练习12：If, Else If, Else

## `if`语句格式
```
if(TEST) {
    CODE;
} else if(TEST) {
    CODE;
} else {
    CODE;
}
```

# 练习13：switch语句

## switch语句的几条原则
* 总是要包含一个`default:`分支，可以让你接住被忽略的输入。
* 不要允许“贯穿”执行，除非你真的想这么做，这种情况下最好添加一个`//fallthrough`的注释。
* 一定要先编写`case`和`break`，再编写其中的代码。
* 如果能够简化的话，用`if`语句代替。

# 练习14：编写并使用函数

## K&R:???
上网浏览不同的人喜欢什么样的函数格式。永远不要使用“K&R”语法，因为它过时了，而且容易使人混乱，但是当你碰到一些人使用这种格式时，要理解代码做了什么。

# 练习15：指针，可怕的指针

## `**`
这是啥意思。。

# 练习16：结构体和指向它们的指针

## 结构体
C中的结构体是其它数据类型（变量）的一个集合，它们储存在一块内存中，然而你可以通过独立的名字来访问每个变量。它们就类似于数据库表中的一行记录，或者面向对象语言中的一个非常简单的类。

# 练习17：堆和栈的内存分配


# 练习18：函数指针


# 练习19：一个简单的对象系统

## c预处理器


# 练习20：Zed的强大的调试宏

## 调试宏
我使用的解决方案是，使用一系列“调试宏”，它们在C中实现了基本的调试和错误处理系统。这个系统非常易于理解，兼容于每个库，并且使C代码更加健壮和简洁。

# 练习21：高级数据类型和控制结构

## 可用的数据类型
`int`, `double`, `float`, `char`, `void`, `enum`

## 类型修饰符
`unsigned`, `signed`, `long`, `short`

## 类型限定符
`const`, `volatile`, `register`

# 练习22：栈、作用域和全局

# 练习23：认识达夫设备